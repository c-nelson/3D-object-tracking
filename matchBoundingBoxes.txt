void matchBoundingBoxes(std::vector<cv::DMatch> &matches, std::map<int, int> &bbBestMatches, DataFrame &prevFrame, DataFrame &currFrame)
{
    std::multimap<int, int> bb_matches;
    // for all matches
    for(auto it = matches.begin(); it != matches.end(); ++it) {
      int cur_idx = it->queryIdx;
      int prev_idx = it->trainIdx;
      auto pt_cur = currFrame.keypoints[cur_idx].pt;
      auto pt_prev = prevFrame.keypoints[prev_idx].pt;
      // find keypoints within bb for both prev and cur
      for(auto prev_bb_it = prevFrame.boundingBoxes.begin(); prev_bb_it != prevFrame.boundingBoxes.end(); ++prev_bb_it){
        for(auto cur_bb_it = currFrame.boundingBoxes.begin(); cur_bb_it != currFrame.boundingBoxes.end(); ++cur_bb_it){
          // if matches is in both bb store each bbs id in map
          if(cur_bb_it->roi.contains(pt_cur) && prev_bb_it->roi.contains(pt_prev)){
            // save all bounding box matches
            //cout << "matching coords:  id1:" << cur_bb_it->boxID << " " << pt_cur.x << "," << pt_cur.y << " : id2:" << prev_bb_it->boxID << " " << pt_prev.x << "," << pt_prev.y << endl;
            bb_matches.insert(std::pair<int, int>(cur_bb_it->boxID, prev_bb_it->boxID));
          }
        }
      }
      // store box ids in multimap
    }
    if(!bb_matches.empty()){
      std::vector<int> completed;
      // loop through all bb matches
      for(auto matches_it = bb_matches.begin(); matches_it != bb_matches.end(); ++matches_it){
        std::cout << "id1: " << matches_it->first << "\tid2: " << matches_it->second << "\tcount: " << endl;
        // if bb id 1 has not been evaluated
        if(std::find(completed.begin(), completed.end(), matches_it->first) == completed.end()){
          // make evaluated
          completed.push_back(matches_it->first);
          std::map<int, int> counts;

          // loop through all of the bb id 1's values
          std::pair <std::multimap<int, int>::iterator, std::multimap<int, int>::iterator> eq;
          eq = bb_matches.equal_range(matches_it->first);
          for(auto equal_it = eq.first; equal_it != eq.second; ++equal_it) {
            // count the times each value for bb id 2 occurs
            //cout << equal_it->first << " | " << equal_it->second;
            if (counts.count(equal_it->second) > 0) {
              //cout << " added =";
              counts[equal_it->second] = counts[equal_it->second] + 1;
              //cout << counts[equal_it->second];
            } else {
              //cout << " init ";
              counts[equal_it->second] = 1;
              //cout << counts[equal_it->second];
            }
            //cout << endl;
          }
          cout << "counts ===" << endl;
          for(auto b = counts.begin(); b != counts.end(); ++b){
            cout << b->first << " | " << b->second << endl;
          }

            // find the max value
          int max = 0;
          int max_id = 0;
          for(auto count_it = counts.begin(); count_it != counts.end(); ++count_it){
            //cout << count_it->first << " | " << count_it->second << " | " << max << " | " << max_id << endl;
            if(count_it->second > max){
              max = count_it->second;
              max_id = count_it->first;
            }
          }
          //std::cout << "ID" << matches_it->first << " matches " << max_id << " with counts:" << max << std::endl;
          // push the two ids to bbBestMatches
          bbBestMatches.insert(pair<int, int>(matches_it->first, max_id));

        }
      }

      std::cout << "======== best matches =======" << std::endl;
      for(auto best_it = bbBestMatches.begin(); best_it != bbBestMatches.end(); ++best_it){
        std::cout << "id1: " << best_it->first << "\tid2: " << best_it->second  << endl;
      }
    }
}